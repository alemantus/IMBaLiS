#include "arduino_secrets.h"
/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/e519a107-7052-4304-8878-2a0e46a0c9ce

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  int rmsValue;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

// Built-in libraries
#include <Timer5.h>
#include <LiquidCrystal.h>
#include <ArduinoGraphics.h> // Arduino_MKRRGB depends on ArduinoGraphics
#include <Arduino_MKRRGB.h>

// 'Local' library
#include "approxFFT.h"

// Constants
#define SAMPLES 256
#define SAMPLES_FREQUENCY 10000
#define RMSFLOOR 388
#define COLUMNS 12
#define LEDOFFSET 500
#define LEDMAX 300
#define BTTNPIN1 A6
#define BTTNPIN2 A5
#define POTENTIOMETERPIN A2
#define AUDIOSENSEPIN A1
#define LEDOUTPUTPIN A0

// IoT substitute pins
#define BTTN1STATEPIN 6
#define BTTN2STATEPIN 7
#define IOTPREF 0 // set to 1 to enable IoT control over button control

// class Initialisation
LiquidCrystal lcd(0, 1, 2, 3, 4, 5);

// Variables
uint16_t adcPosition = 0;
bool activeADC = false;
bool newADC = false;
uint8_t blinkCnt = 0;

int adc0[SAMPLES] = {};
int adc1[SAMPLES] = {};
int dataOut[SAMPLES] = {};
uint16_t ledBuffer[COLUMNS] = {};
int rgb[] = {20, 50, 100};

// Boost the ADC read times.
void AdcBooster() {
  ADC->CTRLA.bit.ENABLE = 0; // Disable ADC
  while( ADC->STATUS.bit.SYNCBUSY == 1 ); // Wait for synchronization
  ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV16 | // Divide Clock by 16.
  ADC_CTRLB_RESSEL_10BIT; // Result on 10 bits
  ADC->AVGCTRL.reg = ADC_AVGCTRL_SAMPLENUM_1 | // 1 sample
  ADC_AVGCTRL_ADJRES(0x00ul); // Adjusting result by 0
  ADC->SAMPCTRL.reg = 0x00; // Sampling Time Length = 0
  ADC->CTRLA.bit.ENABLE = 1; // Enable ADC
  while( ADC->STATUS.bit.SYNCBUSY == 1 ); // Wait for synchronization
}

// Set a given led colomn to a given height
void setVerticalBar(int heightOfBar, int barNum, int lightPower[]) {
  MATRIX.beginDraw();
  MATRIX.stroke(lightPower[0], lightPower[1], lightPower[2]);
  MATRIX.line(barNum, 0, barNum, heightOfBar - 1);
  MATRIX.endDraw();
}

// Finds something similar to the RMS value of the audio signal.
// Only works for arrays of 2^n length.
uint16_t findRMS(int *rmsArray, int lengthOfArray) {
  uint16_t returnVal = 0;
  uint32_t tempVal = 0;

  for (int i = 0; i < lengthOfArray; i++) {
    tempVal+=sq(rmsArray[i]-RMSFLOOR); // Square the value
  }
  while (lengthOfArray != 1) {
    tempVal = tempVal >> 1; // Divide by two
    lengthOfArray = lengthOfArray >> 1; // Divide by two
  }

  returnVal = (uint16_t)sqrt(tempVal);

  return returnVal;
}

// Interrupt used to take ADC measurements
void updateADC() {
  if(adcPosition == SAMPLES) {
    activeADC = !activeADC;
    adcPosition = 0;
    newADC = true;
  }
  if(!activeADC) { //alternates between buffers every 256 samples
    adc0[adcPosition] = analogRead(AUDIOSENSEPIN);
    adcPosition++;
  } else {
    adc1[adcPosition] = analogRead(AUDIOSENSEPIN);
    adcPosition++;
  }
}

void resetRGBShield() {
  MATRIX.beginDraw();
  MATRIX.clear();
  MATRIX.endDraw();
  memset(ledBuffer,0,sizeof(ledBuffer)*COLUMNS);
}

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(256000);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  delay(1000);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // Setup of non auto generated
  AdcBooster(); // Configure ADC to be fast.

  MyTimer5.begin(SAMPLES_FREQUENCY); // Begin timer with 10000 Hz sampling
  MyTimer5.attachInterrupt(updateADC); // Attach interrupt.

  lcd.begin(16,2); // Start LCD with 16 columns and 2 rows.

  // Set button pins to input mode
  pinMode(BTTNPIN1, INPUT);
  pinMode(BTTNPIN2, INPUT);

  // Set DAC resolution
  analogWriteResolution(10);

  MATRIX.begin(); // Start the RGB matrix
  MATRIX.brightness(1); // Set the brightness, due to power concerns keep it low.

}


void loop() {
  ArduinoCloud.update();
  // Your code here
  // State variables
  static bool updateLCD = true;

  // Button 1
  static bool bttn1State = false;
  static bool bttn1StateOld = false;
  static bool bttn1StateLatch = false;

  // Button 2
  static bool bttn2State = false;
  static bool bttn2StateOld = false;
  static bool bttn2StateLatch = false;

  // Cloud state variables
  static bool bttn1FeedbackState = false;
  static bool bttn2FeedbackState = false;

  // RMS and DAC values
  static uint16_t prevRMSValue = 0;
  uint16_t latestRMSValue = 0;
  uint16_t ledDACValue = 0;

  if (newADC) { // A new measurement of SAMPLES length is ready.
    if (activeADC) { // Check which array is currently not being updated
      latestRMSValue = findRMS(adc0, SAMPLES);
      latestRMSValue = (latestRMSValue + prevRMSValue) / 2; // Average with previous RMS
      prevRMSValue = latestRMSValue;

      if (bttn1StateLatch) { // starts FFT and LED visualisation if enabled
        // calculate FFT using adc0 buffer
        Approx_FFT(adc0, SAMPLES, dataOut);

        resetRGBShield();

        binning_12_16(SAMPLES, dataOut, ledBuffer);


        if (bttn2StateLatch) { //chooses between 2 color schemes for the MKRRGB shield
          // monocolor
          for (int i = 0; i < COLUMNS; i++) {
            setVerticalBar(map(ledBuffer[i], 0, 15000, 0, 7), i, rgb);
          }
        } else {
          // multicolor
          MATRIX.beginDraw();

          for (int i = 0; i < COLUMNS; i++) {
            int height = map(ledBuffer[i], 0, 15000, 0, 7);
            int value = ledBuffer[i]-1875*height;
            int r = 0;
            int g = 0;
            if (value<=625){
              g = map(ledBuffer[i], 0, 625, 0, 255);
            } else if (value<=1250){
              g = 255;
              r = map(ledBuffer[i], 626, 1250, 0, 255);
            } else {
              r = 255;
              g = map(ledBuffer[i], 1251, 1875, 255, 0);
            }
            rgb[0] = 255;
            rgb[1] = 0;
            rgb[2] = 0;
            setVerticalBar(height, i, rgb);
            MATRIX.beginDraw();
            MATRIX.set(i, height, r, g, 0);
            MATRIX.endDraw();
          }
        }
      } else {
        resetRGBShield();
      }
    } else {
      // section is same as above, however uses adc1 instead of adc0
      latestRMSValue = findRMS(adc1, SAMPLES);
      latestRMSValue = (latestRMSValue + prevRMSValue) / 2;
      prevRMSValue = latestRMSValue;

      if (bttn1StateLatch) { // starts FFT and LED visualisation if enabled
        // calculate FFT using adc1 buffer
        Approx_FFT(adc1, SAMPLES, dataOut);

        resetRGBShield();

        binning_12_16(SAMPLES, dataOut, ledBuffer);

        if (bttn2StateLatch) { //chooses between 2 color schemes for the MKRRGB shield
          // monocolor
          for (int i = 0; i < COLUMNS; i++) {
            setVerticalBar(map(ledBuffer[i], 0, 15000, 0, 7), i, rgb);
          }
        } else {
          // multicolor
          MATRIX.beginDraw();

          for (int i = 0; i < COLUMNS; i++) {
            int height = map(ledBuffer[i], 0, 15000, 0, 7);
            int value = ledBuffer[i]-1875*height;
            int r = 0;
            int g = 0;
            if (value<=625){
              g = map(ledBuffer[i], 0, 625, 0, 255);
            } else if (value<=1250){
              g = 255;
              r = map(ledBuffer[i], 626, 1250, 0, 255);
            } else {
              r = 255;
              g = map(ledBuffer[i], 1251, 1875, 255, 0);
            }
            rgb[0] = 255;
            rgb[1] = 0;
            rgb[2] = 0;
            setVerticalBar(height, i, rgb);
            MATRIX.beginDraw();
            MATRIX.set(i, height, r, g, 0);
            MATRIX.endDraw();
          }
        }
      } else {
        resetRGBShield();
      }
    }

    // RMS and voltage from RMS of input signal
    rmsValue = (int)latestRMSValue;
    float rmsVoltage = (float)(rmsValue/1023.0*3.3);
    ledDACValue = map(rmsValue, 0, LEDMAX, LEDOFFSET, 1023); // map to high min val since LED forward voltage = 2V
    analogWrite(LEDOUTPUTPIN, ledDACValue); // write to pulsing LED

    lcd.setCursor(0,0);
    lcd.print("RMS:    ");
    lcd.setCursor(5,0);
    lcd.print(rmsVoltage,3);

    // Has there been a press of the button/from IoT?
    // IoT/button is enabled/disbaled, chosen at upload
    if (IOTPREF) {
      bttn1FeedbackState = digitalRead(BTTN1STATEPIN);
      bttn2FeedbackState = digitalRead(BTTN2STATEPIN);
      bttn1StateLatch = bttn1FeedbackState;
      bttn2StateLatch = bttn2FeedbackState;
      updateLCD = true;
    } else {
      bttn1State = digitalRead(BTTNPIN1);
      bttn2State = digitalRead(BTTNPIN2);
      //button1 latch
      if (bttn1State != bttn1StateOld) {
        bttn1StateOld = bttn1State;
        if (bttn1State == HIGH) {
          bttn1StateLatch = !bttn1StateLatch;
          updateLCD = true;
        }
      }
      //button2 latch
      if (bttn2State != bttn2StateOld) {
        bttn2StateOld = bttn2State;
        if (bttn2State == HIGH) {
          bttn2StateLatch = !bttn2StateLatch;
          updateLCD = true;
        }
      }
    }

    // Write to LCD
    if (updateLCD) {
      lcd.setCursor(0,1);
      lcd.print("MODE:      ");
      lcd.setCursor(6,1);
      if (bttn1StateLatch) {
        lcd.print("ON/");
      } else {
        lcd.print("OFF/");
      }
      if (bttn2StateLatch) {
        lcd.print("1");
      } else {
        lcd.print("2");
      }
      // set monocolor values
      if (bttn2StateLatch) {
        rgb[0] = 20;
        rgb[1] = 50;
        rgb[2] = 100;
      }
      updateLCD = false;
    }

    // is alive lED blink
    if (blinkCnt == 20) {
      digitalWrite(LED_BUILTIN, HIGH);
    } else if (blinkCnt == 39) {
      digitalWrite(LED_BUILTIN, LOW);
      blinkCnt = 0;
    }
    blinkCnt++;

    newADC = false;
  }
}
